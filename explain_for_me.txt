Модуль по сути это блок кода который выполняет одну определенную задачу. Это как в джанго приложения, которые делают одну определенную задачу
Если мы делаем приложие для аутентификации и мы делаем user модуль для работы с пользователя, модуль видео для работы с видео и тд.
Контроллер - это что-то что берет url и когда получает урл то вызывает функцию определенную
Nestjs стремится отделить бизнес логику от логики контролееров.
контролелр должен делать одну вещь : связать url с выполняемой функцией.
То есть описание выполняемой функции должно хранится в сервисах а в контроллерах просто вызываться.
То есть в сервисах мы видим класс в котором лежат функции которые мы вызываем из контроллеров

Декоратор @Param для получения параметра (id) из url. movies/id
Декоратор @Query для получения get (name) параметров которые идут после вопросительного знак - /search?name=KinosImenemAU
Декоратор @Body для получения тела запроса в json формате. при post запросе

генерирует призму в проекте npx prisma init --datasource-provider sqlite --output ../generated/prisma
npx prisma migrate миграции

Pipes имеют два типичных вариантов использования:

Преобразование: преобразование входных данных в нужную форму (например, от строки в целое число)
Валидация: оценить входные данные и, если действителен, просто пропустите их через неизменную; В противном случае, добавьте исключение

В обоих случаях трубы работают над аргументами, обрабатываемыми обработчиком маршрута контроллера. Nest вмешивает трубу непосредственно перед вызовом метода, и труба получает аргументы, предназначенные для метода, и действует на них. Любая операция преобразования или валидации происходит в то время, после чего обработчик маршрута вызывает любые (потенциально) преобразованные аргументы.
    ValidationPipe
    ParseIntPipe
    ParseFloatPipe
    ParseBoolPipe
    ParseArrayPipe
    ParseUUIDPipe
    ParseEnumPipe
    DefaultValuePipe
    ParseFilePipe
    ParseDatePipe
    
@Get(':id')
async findOne(@Param('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}


Загрузка файлов
@Post('upload')
@UseInterceptors(FileInterceptor('file'))
uploadFile(@UploadedFile() file: Express.Multer.File) {
  console.log(file);
}
The FileInterceptor() decorator is exported from the @nestjs/platform-express package. The @UploadedFile() decorator is exported from @nestjs/common. 

Pipe - преобразует в параметрах запроса наши цифры из строки в инт и не только
Interceptor - нужен для загрузки файлов, а формат multipart/form-data это передача файла составным запросом с помощью multipart/form-data

MIddleeware - идет проверкой на все запросы абсолютно и является прослойкой между клиентом и сервером постоянно
А Guard - это то же самое, можно накинуть на отдельные части.

